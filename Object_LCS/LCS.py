import numpy as np
from cmath import inf
import matplotlib.pyplot as plt
from opendrift.models.oceandrift import OceanDrift
from opendrift.readers import reader_netCDF_CF_generic
import xarray as xr

def FTLE(DataArray, outfile, separation = None, duration=None, model=True, example_model_file = '/lustre/storeB/project/fou/hi/barents_eps/eps/barents_mean_20231018T06Z.nc'):
    """
        Computes LCSs using the FTLE approach using the file from ParticleAdvector.py
        The function is tailored for attracting hyperbolic LCSs. If repelling LCSs are of interest, the resulting array needs to be reversed, i.e. RLCS[::-1, ::-1].
    Args:
        DataArray  [xr.DataArray]    :   Name of file which contains intial and final positions of particles. Generated by ParticleAdvector.py
        outfile    [str]             :   Name of file where LCSs are saved to.
        DG         [bool]            :   Set to "True" if LCSs are to be generated for the Double-Gyre system. 
    Retunts:  
        outfile.nc [str]             :   Name of file where LCSs are saved to. 
    """
    if separation is not None:
        sep = separation
    else:
        sep = DataArray.separation.values
    if duration is not None:
        dur = duration
    else:
        dur = DataArray.duration.values

    x0 = np.array(DataArray.lon)
    y0 = np.array(DataArray.lat)

    nx, ny = x0.shape[0], x0.shape[1]
    x1 = np.reshape(np.array(DataArray.nlon), (nx, ny))
    y1 = np.reshape(np.array(DataArray.nlat), (nx, ny))

    largest_eig = np.zeros([nx,ny])
    for i in range(1,nx-1):
        for j in range(1,ny-1):
            
            F = np.zeros([2,2])
            F[0,0] = (x1[i+1, j]-x1[i-1, j])/(2*sep)
            F[0,1] = (x1[i, j+1]-x1[i, j-1])/(2*sep)
            F[1,0] = (y1[i+1, j]-y1[i-1, j])/(2*sep)
            F[1,1] = (y1[i, j+1]-y1[i, j-1])/(2*sep)
            
            C = np.dot(np.transpose(F), F)
            try:
                eig = np.linalg.eigvals(C)
            except:
                eig = 0
            np.seterr(divide = 'ignore')
            largest_eig[i,j] = np.log(np.sqrt(np.max(eig)))/dur
    largest_eig[largest_eig==-inf]=np.nan
    
    if model is True:
        # It's important to have the correct file here for the projection
        r = reader_netCDF_CF_generic.Reader(example_model_file)
        x0, y0 = r.xy2lonlat(x0, y0)
    
    LCS = xr.Dataset(coords = dict(lon=(['x', 'y'], x0), lat=(['x','y'], y0)),
                    data_vars = dict(ALCS=(['x', 'y'], largest_eig[::-1,::-1])))

    LCS.to_netcdf(f'{outfile}.nc')

    return LCS


if __name__ == '__main__':
    from ParticleAdvector import Advection
    from datetime import datetime, timedelta
    file = '/lustre/storeB/project/fou/hi/barents_eps/eps/barents_eps_20230618T00Z.nc'
    file = 'https://thredds.met.no/thredds/dodsC/fou-hi/norkyst800m-1h/NorKyst-800m_ZDEPTHS_his.an.2023040700.nc'
    ds = xr.open_dataset(file)
    lons=[4.5,23]
    lats=[67,69.9]
    lons = []
    ts=-3600
    sep=1000
    dur=12
    start = datetime(2023,6,19)
    start = timedelta(hours=24)
    t = Advection(file, lons, lats, ts, sep, dur, start)
    parts = t.run()
    LCS = FTLE(parts, 'example', example_model_file=file)
    LCS = xr.open_dataset('example.nc')

    plt.pcolormesh(LCS.lon, LCS.lat, LCS.ALCS, vmin=0, vmax=0.08)

    plt.show()
